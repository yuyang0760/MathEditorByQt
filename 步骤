修复的 Qt6 兼容版本
1. TextInputWidget.h（修复版本）
cpp
#ifndef TEXTINPUTWIDGET_H
#define TEXTINPUTWIDGET_H

#include <QWidget>
#include <QGraphicsView>
#include <QGraphicsScene>
#include <QTimer>
#include <QInputMethodEvent>

class GraphicsTextItem;

class TextInputWidget : public QGraphicsView
{
    Q_OBJECT
    
public:
    TextInputWidget(QWidget *parent = nullptr);
    
protected:
    void mousePressEvent(QMouseEvent *event) override;
    void keyPressEvent(QKeyEvent *event) override;
    void inputMethodEvent(QInputMethodEvent *event) override;
    QVariant inputMethodQuery(Qt::InputMethodQuery query) const override;
    
private slots:
    void blinkCursor();
    
private:
    void updateCursor();
    void updateMicroFocusPosition();  // 重命名以避免混淆
    QPointF getCursorPosition() const;
    
    QGraphicsScene *scene;
    GraphicsTextItem *activeTextItem;
    QTimer *cursorTimer;
    bool cursorVisible;
    
    // 输入法状态
    QString composingText;
    bool isComposing;
};

#endif // TEXTINPUTWIDGET_H
2. TextInputWidget.cpp（修复版本）
cpp
#include "TextInputWidget.h"
#include "GraphicsTextItem.h"
#include <QMouseEvent>
#include <QKeyEvent>
#include <QInputMethodEvent>
#include <QDebug>
#include <QScrollBar>
#include <QApplication>

TextInputWidget::TextInputWidget(QWidget *parent)
    : QGraphicsView(parent)
    , scene(nullptr)
    , activeTextItem(nullptr)
    , cursorVisible(true)
    , isComposing(false)
{
    // 创建场景
    scene = new QGraphicsScene(this);
    scene->setSceneRect(0, 0, 800, 600);
    setScene(scene);
    
    // 设置背景
    scene->setBackgroundBrush(Qt::white);
    
    // 启用键盘输入
    setFocusPolicy(Qt::StrongFocus);
    
    // 设置输入法
    setAttribute(Qt::WA_InputMethodEnabled, true);
    
    // 创建光标闪烁定时器
    cursorTimer = new QTimer(this);
    connect(cursorTimer, &QTimer::timeout, this, &TextInputWidget::blinkCursor);
    cursorTimer->start(500); // 500ms 闪烁间隔
    
    // 设置视图
    setRenderHint(QPainter::Antialiasing);
    setViewportUpdateMode(QGraphicsView::FullViewportUpdate);
    
    // 添加测试文本
    GraphicsTextItem *testItem = new GraphicsTextItem();
    testItem->setText("点击此处开始输入...");
    testItem->setPos(100, 100);
    scene->addItem(testItem);
}

void TextInputWidget::mousePressEvent(QMouseEvent *event)
{
    QGraphicsView::mousePressEvent(event);
    
    // 将点击位置转换为场景坐标
    QPointF scenePos = mapToScene(event->pos());
    
    // 查找点击的文本项
    QGraphicsItem *item = scene->itemAt(scenePos, transform());
    GraphicsTextItem *textItem = qgraphicsitem_cast<GraphicsTextItem*>(item);
    
    if (textItem)
    {
        // 如果点击了文本项，激活它
        if (activeTextItem)
        {
            activeTextItem->setActive(false);
        }
        
        activeTextItem = textItem;
        activeTextItem->setActive(true);
        
        // 计算点击位置在文本中的索引
        QPointF itemPos = textItem->mapFromScene(scenePos);
        int cursorPos = textItem->getCursorPositionAt(itemPos.x());
        activeTextItem->setCursorPosition(cursorPos);
        
        // 激活输入法
        setFocus();
        
        // 更新输入法查询
        updateMicroFocusPosition();
        
        // 确保光标可见
        updateCursor();
    }
    else if (activeTextItem)
    {
        // 点击空白处，取消激活当前文本项
        activeTextItem->setActive(false);
        activeTextItem = nullptr;
        cursorTimer->stop();
    }
}

void TextInputWidget::keyPressEvent(QKeyEvent *event)
{
    if (!activeTextItem)
    {
        QGraphicsView::keyPressEvent(event);
        return;
    }
    
    bool handled = false;
    
    switch (event->key())
    {
    case Qt::Key_Backspace:
        activeTextItem->backspace();
        handled = true;
        break;
        
    case Qt::Key_Delete:
        activeTextItem->deleteChar();
        handled = true;
        break;
        
    case Qt::Key_Left:
        activeTextItem->moveCursorLeft();
        handled = true;
        break;
        
    case Qt::Key_Right:
        activeTextItem->moveCursorRight();
        handled = true;
        break;
        
    case Qt::Key_Home:
        activeTextItem->moveCursorToStart();
        handled = true;
        break;
        
    case Qt::Key_End:
        activeTextItem->moveCursorToEnd();
        handled = true;
        break;
        
    case Qt::Key_Return:
    case Qt::Key_Enter:
        // 创建新文本项
        {
            GraphicsTextItem *newItem = new GraphicsTextItem();
            newItem->setText("");
            newItem->setPos(activeTextItem->pos().x(), 
                           activeTextItem->pos().y() + activeTextItem->boundingRect().height() + 5);
            scene->addItem(newItem);
            
            // 激活新文本项
            activeTextItem->setActive(false);
            activeTextItem = newItem;
            activeTextItem->setActive(true);
            activeTextItem->setCursorPosition(0);
            handled = true;
        }
        break;
    }
    
    if (handled)
    {
        event->accept();
        updateCursor();
        updateMicroFocusPosition();
    }
    else
    {
        QGraphicsView::keyPressEvent(event);
    }
}

void TextInputWidget::inputMethodEvent(QInputMethodEvent *event)
{
    if (!activeTextItem)
    {
        event->ignore();
        return;
    }
    
    // 获取预编辑文本（输入法组合中的文本）
    QString preeditString = event->preeditString();
    QString commitString = event->commitString();
    
    qDebug() << "Input Method Event:";
    qDebug() << "  Preedit:" << preeditString;
    qDebug() << "  Commit:" << commitString;
    qDebug() << "  Replacement Start:" << event->replacementStart();
    qDebug() << "  Replacement Length:" << event->replacementLength();
    
    if (!preeditString.isEmpty())
    {
        // 有预编辑文本，说明正在输入法组合
        isComposing = true;
        composingText = preeditString;
        
        // 更新文本项显示预编辑文本
        activeTextItem->setComposingText(preeditString);
    }
    else if (!commitString.isEmpty())
    {
        // 有提交文本，输入法组合完成
        isComposing = false;
        composingText.clear();
        
        // 插入文本
        activeTextItem->insertText(commitString);
    }
    else if (event->replacementLength() > 0)
    {
        // 替换文本
        activeTextItem->replaceText(event->replacementStart(), 
                                   event->replacementLength(), 
                                   event->commitString());
    }
    else
    {
        // 其他输入法事件
        isComposing = false;
        composingText.clear();
        activeTextItem->clearComposingText();
    }
    
    // 更新光标和输入法
    updateCursor();
    updateMicroFocusPosition();
    
    event->accept();
}

QVariant TextInputWidget::inputMethodQuery(Qt::InputMethodQuery query) const
{
    if (!activeTextItem)
        return QGraphicsView::inputMethodQuery(query);
    
    switch (query)
    {
    case Qt::ImCursorRectangle:
    {
        // 返回光标的矩形区域（输入法候选框会显示在这个位置附近）
        QRectF cursorRect = activeTextItem->getCursorRect();
        QPointF scenePos = activeTextItem->mapToScene(cursorRect.topLeft());
        
        // 将场景坐标转换为视图坐标
        QPoint viewPos = mapFromScene(scenePos);
        
        // 将视图坐标转换为窗口坐标
        QRect rect(viewPos, cursorRect.size().toSize());
        
        return rect;
    }
    
    case Qt::ImAnchorRectangle:
        // 锚点矩形（通常与光标矩形相同）
        return inputMethodQuery(Qt::ImCursorRectangle);
        
    case Qt::ImFont:
        // 返回当前字体
        return activeTextItem->getFont();
        
    case Qt::ImCursorPosition:
        // 返回光标位置
        return activeTextItem->getCursorPosition();
        
    case Qt::ImSurroundingText:
        // 返回光标周围的文本
        return activeTextItem->getText();
        
    case Qt::ImCurrentSelection:
        // 当前选择的文本（这里不实现选择）
        return QString();
        
    case Qt::ImMaximumTextLength:
        // 最大文本长度
        return 1000;
        
    case Qt::ImAnchorPosition:
        // 锚点位置（通常与光标位置相同）
        return activeTextItem->getCursorPosition();
        
    case Qt::ImHints:
        // 输入法提示
        return QVariant(static_cast<int>(Qt::ImhNone));
        
    case Qt::ImPreferredLanguage:
        // 首选语言
        return "zh-CN";
        
    default:
        return QGraphicsView::inputMethodQuery(query);
    }
}

void TextInputWidget::blinkCursor()
{
    if (activeTextItem && activeTextItem->isActive())
    {
        cursorVisible = !cursorVisible;
        activeTextItem->setCursorVisible(cursorVisible);
        activeTextItem->update();
    }
}

void TextInputWidget::updateCursor()
{
    if (activeTextItem)
    {
        cursorVisible = true;
        activeTextItem->setCursorVisible(cursorVisible);
        activeTextItem->update();
    }
}

void TextInputWidget::updateMicroFocusPosition()
{
    // 通知Qt更新输入法位置
    // 在Qt6中，我们需要确保输入法知道光标位置
    if (activeTextItem)
    {
        // 强制更新输入法查询
        QInputMethod *im = QGuiApplication::inputMethod();
        if (im)
        {
            im->update(Qt::ImQueryAll);
        }
    }
}
3. GraphicsTextItem.h（保持不变）
cpp
#ifndef GRAPHICSTEXTITEM_H
#define GRAPHICSTEXTITEM_H

#include <QGraphicsItem>
#include <QFont>

class GraphicsTextItem : public QGraphicsItem
{
public:
    GraphicsTextItem(QGraphicsItem *parent = nullptr);
    
    // QGraphicsItem 接口
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    
    // 文本操作
    void setText(const QString &text);
    QString getText() const;
    
    // 光标操作
    void setCursorPosition(int position);
    int getCursorPosition() const;
    void setCursorVisible(bool visible);
    void setActive(bool active);
    bool isActive() const;
    
    // 输入法支持
    void setComposingText(const QString &text);
    void clearComposingText();
    
    // 编辑操作
    void insertText(const QString &text);
    void backspace();
    void deleteChar();
    void moveCursorLeft();
    void moveCursorRight();
    void moveCursorToStart();
    void moveCursorToEnd();
    void replaceText(int start, int length, const QString &text);
    
    // 光标位置计算
    int getCursorPositionAt(qreal x) const;
    QRectF getCursorRect() const;
    QFont getFont() const;
    
private:
    QString text;
    QString composingText;
    int cursorPosition;
    bool cursorVisible;
    bool isActiveItem;
    QFont font;
    
    // 计算文本宽度
    qreal textWidthUpTo(int position) const;
};

#endif // GRAPHICSTEXTITEM_H
4. GraphicsTextItem.cpp（保持不变）
cpp
#include "GraphicsTextItem.h"
#include <QPainter>
#include <QFontMetricsF>
#include <QDebug>

GraphicsTextItem::GraphicsTextItem(QGraphicsItem *parent)
    : QGraphicsItem(parent)
    , cursorPosition(0)
    , cursorVisible(false)
    , isActiveItem(false)
{
    // 设置字体
    font.setFamily("Microsoft YaHei");
    font.setPointSize(12);
    
    // 设置标志
    setFlag(QGraphicsItem::ItemIsFocusable);
    setAcceptHoverEvents(true);
}

QRectF GraphicsTextItem::boundingRect() const
{
    QFontMetricsF metrics(font);
    qreal width = metrics.horizontalAdvance(text + composingText) + 2; // 加2给光标留空间
    qreal height = metrics.height() + 4;
    
    return QRectF(0, 0, width, height);
}

void GraphicsTextItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option);
    Q_UNUSED(widget);
    
    painter->setFont(font);
    
    // 绘制文本背景（如果激活）
    if (isActiveItem)
    {
        painter->fillRect(boundingRect(), QColor(240, 240, 255));
    }
    
    // 绘制文本
    painter->setPen(Qt::black);
    
    // 如果有预编辑文本（输入法组合），需要特殊处理
    if (!composingText.isEmpty())
    {
        // 绘制光标前的文本
        QString beforeCursor = text.left(cursorPosition);
        painter->drawText(0, font.pointSize(), beforeCursor);
        
        // 绘制预编辑文本（带下划线）
        QFont underlineFont = font;
        underlineFont.setUnderline(true);
        painter->setFont(underlineFont);
        
        qreal x = QFontMetricsF(font).horizontalAdvance(beforeCursor);
        painter->drawText(x, font.pointSize(), composingText);
        
        // 恢复字体
        painter->setFont(font);
        
        // 绘制光标后的文本
        QString afterCursor = text.mid(cursorPosition);
        x += QFontMetricsF(font).horizontalAdvance(composingText);
        painter->drawText(x, font.pointSize(), afterCursor);
    }
    else
    {
        // 没有预编辑文本，直接绘制全部文本
        painter->drawText(0, font.pointSize(), text);
    }
    
    // 绘制光标
    if (cursorVisible && isActiveItem)
    {
        qreal cursorX = textWidthUpTo(cursorPosition);
        
        painter->setPen(QPen(Qt::black, 2));
        painter->drawLine(QPointF(cursorX, 0), 
                         QPointF(cursorX, QFontMetricsF(font).height()));
    }
}

void GraphicsTextItem::setText(const QString &text)
{
    this->text = text;
    prepareGeometryChange();
    update();
}

QString GraphicsTextItem::getText() const
{
    return text;
}

void GraphicsTextItem::setCursorPosition(int position)
{
    cursorPosition = qBound(0, position, text.length());
    update();
}

int GraphicsTextItem::getCursorPosition() const
{
    return cursorPosition;
}

void GraphicsTextItem::setCursorVisible(bool visible)
{
    cursorVisible = visible;
    update();
}

void GraphicsTextItem::setActive(bool active)
{
    isActiveItem = active;
    cursorVisible = active;
    update();
}

bool GraphicsTextItem::isActive() const
{
    return isActiveItem;
}

void GraphicsTextItem::setComposingText(const QString &text)
{
    composingText = text;
    prepareGeometryChange();
    update();
}

void GraphicsTextItem::clearComposingText()
{
    composingText.clear();
    prepareGeometryChange();
    update();
}

void GraphicsTextItem::insertText(const QString &text)
{
    this->text.insert(cursorPosition, text);
    cursorPosition += text.length();
    clearComposingText();
    prepareGeometryChange();
    update();
}

void GraphicsTextItem::backspace()
{
    if (cursorPosition > 0)
    {
        text.remove(cursorPosition - 1, 1);
        cursorPosition--;
        clearComposingText();
        prepareGeometryChange();
        update();
    }
}

void GraphicsTextItem::deleteChar()
{
    if (cursorPosition < text.length())
    {
        text.remove(cursorPosition, 1);
        clearComposingText();
        prepareGeometryChange();
        update();
    }
}

void GraphicsTextItem::moveCursorLeft()
{
    if (cursorPosition > 0)
    {
        cursorPosition--;
        clearComposingText();
        update();
    }
}

void GraphicsTextItem::moveCursorRight()
{
    if (cursorPosition < text.length())
    {
        cursorPosition++;
        clearComposingText();
        update();
    }
}

void GraphicsTextItem::moveCursorToStart()
{
    cursorPosition = 0;
    clearComposingText();
    update();
}

void GraphicsTextItem::moveCursorToEnd()
{
    cursorPosition = text.length();
    clearComposingText();
    update();
}

void GraphicsTextItem::replaceText(int start, int length, const QString &text)
{
    if (start >= 0 && start < this->text.length())
    {
        length = qMin(length, this->text.length() - start);
        this->text.replace(start, length, text);
        
        if (cursorPosition >= start + length)
        {
            cursorPosition += text.length() - length;
        }
        else if (cursorPosition > start)
        {
            cursorPosition = start + text.length();
        }
        
        clearComposingText();
        prepareGeometryChange();
        update();
    }
}

int GraphicsTextItem::getCursorPositionAt(qreal x) const
{
    if (text.isEmpty()) return 0;
    
    QFontMetricsF metrics(font);
    
    // 简单实现：找到最接近的字符位置
    for (int i = 0; i <= text.length(); i++)
    {
        qreal width = metrics.horizontalAdvance(text.left(i));
        if (width >= x)
        {
            return i;
        }
    }
    
    return text.length();
}

QRectF GraphicsTextItem::getCursorRect() const
{
    QFontMetricsF metrics(font);
    qreal cursorX = textWidthUpTo(cursorPosition);
    
    return QRectF(cursorX, 0, 2, metrics.height());
}

QFont GraphicsTextItem::getFont() const
{
    return font;
}

qreal GraphicsTextItem::textWidthUpTo(int position) const
{
    QFontMetricsF metrics(font);
    
    if (position <= cursorPosition)
    {
        // 光标前的文本
        return metrics.horizontalAdvance(text.left(position));
    }
    else
    {
        // 包括预编辑文本
        qreal baseWidth = metrics.horizontalAdvance(text.left(cursorPosition));
        baseWidth += metrics.horizontalAdvance(composingText);
        baseWidth += metrics.horizontalAdvance(text.mid(cursorPosition, position - cursorPosition));
        return baseWidth;
    }
}
5. main.cpp（保持不变）
cpp
#include <QApplication>
#include <QMainWindow>
#include "TextInputWidget.h"

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    
    QMainWindow window;
    window.setWindowTitle("Qt6 图形视图文本输入示例");
    window.resize(800, 600);
    
    TextInputWidget *widget = new TextInputWidget(&window);
    window.setCentralWidget(widget);
    
    window.show();
    
    return app.exec();